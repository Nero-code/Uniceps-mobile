// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'measurment_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MeasurementEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getMeasurements,
    required TResult Function(Measurement m) createMeasurement,
    required TResult Function(Measurement m) updateMeasurement,
    required TResult Function(Measurement m) deleteMeasurement,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getMeasurements,
    TResult? Function(Measurement m)? createMeasurement,
    TResult? Function(Measurement m)? updateMeasurement,
    TResult? Function(Measurement m)? deleteMeasurement,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getMeasurements,
    TResult Function(Measurement m)? createMeasurement,
    TResult Function(Measurement m)? updateMeasurement,
    TResult Function(Measurement m)? deleteMeasurement,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetMeasurements value) getMeasurements,
    required TResult Function(_CreateMeasurement value) createMeasurement,
    required TResult Function(_UpdateMeasurement value) updateMeasurement,
    required TResult Function(_DeleteMeasurement value) deleteMeasurement,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetMeasurements value)? getMeasurements,
    TResult? Function(_CreateMeasurement value)? createMeasurement,
    TResult? Function(_UpdateMeasurement value)? updateMeasurement,
    TResult? Function(_DeleteMeasurement value)? deleteMeasurement,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetMeasurements value)? getMeasurements,
    TResult Function(_CreateMeasurement value)? createMeasurement,
    TResult Function(_UpdateMeasurement value)? updateMeasurement,
    TResult Function(_DeleteMeasurement value)? deleteMeasurement,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MeasurementEventCopyWith<$Res> {
  factory $MeasurementEventCopyWith(
          MeasurementEvent value, $Res Function(MeasurementEvent) then) =
      _$MeasurementEventCopyWithImpl<$Res, MeasurementEvent>;
}

/// @nodoc
class _$MeasurementEventCopyWithImpl<$Res, $Val extends MeasurementEvent>
    implements $MeasurementEventCopyWith<$Res> {
  _$MeasurementEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetMeasurementsImplCopyWith<$Res> {
  factory _$$GetMeasurementsImplCopyWith(_$GetMeasurementsImpl value,
          $Res Function(_$GetMeasurementsImpl) then) =
      __$$GetMeasurementsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetMeasurementsImplCopyWithImpl<$Res>
    extends _$MeasurementEventCopyWithImpl<$Res, _$GetMeasurementsImpl>
    implements _$$GetMeasurementsImplCopyWith<$Res> {
  __$$GetMeasurementsImplCopyWithImpl(
      _$GetMeasurementsImpl _value, $Res Function(_$GetMeasurementsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetMeasurementsImpl implements _GetMeasurements {
  const _$GetMeasurementsImpl();

  @override
  String toString() {
    return 'MeasurementEvent.getMeasurements()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetMeasurementsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getMeasurements,
    required TResult Function(Measurement m) createMeasurement,
    required TResult Function(Measurement m) updateMeasurement,
    required TResult Function(Measurement m) deleteMeasurement,
  }) {
    return getMeasurements();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getMeasurements,
    TResult? Function(Measurement m)? createMeasurement,
    TResult? Function(Measurement m)? updateMeasurement,
    TResult? Function(Measurement m)? deleteMeasurement,
  }) {
    return getMeasurements?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getMeasurements,
    TResult Function(Measurement m)? createMeasurement,
    TResult Function(Measurement m)? updateMeasurement,
    TResult Function(Measurement m)? deleteMeasurement,
    required TResult orElse(),
  }) {
    if (getMeasurements != null) {
      return getMeasurements();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetMeasurements value) getMeasurements,
    required TResult Function(_CreateMeasurement value) createMeasurement,
    required TResult Function(_UpdateMeasurement value) updateMeasurement,
    required TResult Function(_DeleteMeasurement value) deleteMeasurement,
  }) {
    return getMeasurements(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetMeasurements value)? getMeasurements,
    TResult? Function(_CreateMeasurement value)? createMeasurement,
    TResult? Function(_UpdateMeasurement value)? updateMeasurement,
    TResult? Function(_DeleteMeasurement value)? deleteMeasurement,
  }) {
    return getMeasurements?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetMeasurements value)? getMeasurements,
    TResult Function(_CreateMeasurement value)? createMeasurement,
    TResult Function(_UpdateMeasurement value)? updateMeasurement,
    TResult Function(_DeleteMeasurement value)? deleteMeasurement,
    required TResult orElse(),
  }) {
    if (getMeasurements != null) {
      return getMeasurements(this);
    }
    return orElse();
  }
}

abstract class _GetMeasurements implements MeasurementEvent {
  const factory _GetMeasurements() = _$GetMeasurementsImpl;
}

/// @nodoc
abstract class _$$CreateMeasurementImplCopyWith<$Res> {
  factory _$$CreateMeasurementImplCopyWith(_$CreateMeasurementImpl value,
          $Res Function(_$CreateMeasurementImpl) then) =
      __$$CreateMeasurementImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Measurement m});
}

/// @nodoc
class __$$CreateMeasurementImplCopyWithImpl<$Res>
    extends _$MeasurementEventCopyWithImpl<$Res, _$CreateMeasurementImpl>
    implements _$$CreateMeasurementImplCopyWith<$Res> {
  __$$CreateMeasurementImplCopyWithImpl(_$CreateMeasurementImpl _value,
      $Res Function(_$CreateMeasurementImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? m = null,
  }) {
    return _then(_$CreateMeasurementImpl(
      null == m
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as Measurement,
    ));
  }
}

/// @nodoc

class _$CreateMeasurementImpl implements _CreateMeasurement {
  const _$CreateMeasurementImpl(this.m);

  @override
  final Measurement m;

  @override
  String toString() {
    return 'MeasurementEvent.createMeasurement(m: $m)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateMeasurementImpl &&
            (identical(other.m, m) || other.m == m));
  }

  @override
  int get hashCode => Object.hash(runtimeType, m);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateMeasurementImplCopyWith<_$CreateMeasurementImpl> get copyWith =>
      __$$CreateMeasurementImplCopyWithImpl<_$CreateMeasurementImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getMeasurements,
    required TResult Function(Measurement m) createMeasurement,
    required TResult Function(Measurement m) updateMeasurement,
    required TResult Function(Measurement m) deleteMeasurement,
  }) {
    return createMeasurement(m);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getMeasurements,
    TResult? Function(Measurement m)? createMeasurement,
    TResult? Function(Measurement m)? updateMeasurement,
    TResult? Function(Measurement m)? deleteMeasurement,
  }) {
    return createMeasurement?.call(m);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getMeasurements,
    TResult Function(Measurement m)? createMeasurement,
    TResult Function(Measurement m)? updateMeasurement,
    TResult Function(Measurement m)? deleteMeasurement,
    required TResult orElse(),
  }) {
    if (createMeasurement != null) {
      return createMeasurement(m);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetMeasurements value) getMeasurements,
    required TResult Function(_CreateMeasurement value) createMeasurement,
    required TResult Function(_UpdateMeasurement value) updateMeasurement,
    required TResult Function(_DeleteMeasurement value) deleteMeasurement,
  }) {
    return createMeasurement(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetMeasurements value)? getMeasurements,
    TResult? Function(_CreateMeasurement value)? createMeasurement,
    TResult? Function(_UpdateMeasurement value)? updateMeasurement,
    TResult? Function(_DeleteMeasurement value)? deleteMeasurement,
  }) {
    return createMeasurement?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetMeasurements value)? getMeasurements,
    TResult Function(_CreateMeasurement value)? createMeasurement,
    TResult Function(_UpdateMeasurement value)? updateMeasurement,
    TResult Function(_DeleteMeasurement value)? deleteMeasurement,
    required TResult orElse(),
  }) {
    if (createMeasurement != null) {
      return createMeasurement(this);
    }
    return orElse();
  }
}

abstract class _CreateMeasurement implements MeasurementEvent {
  const factory _CreateMeasurement(final Measurement m) =
      _$CreateMeasurementImpl;

  Measurement get m;
  @JsonKey(ignore: true)
  _$$CreateMeasurementImplCopyWith<_$CreateMeasurementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateMeasurementImplCopyWith<$Res> {
  factory _$$UpdateMeasurementImplCopyWith(_$UpdateMeasurementImpl value,
          $Res Function(_$UpdateMeasurementImpl) then) =
      __$$UpdateMeasurementImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Measurement m});
}

/// @nodoc
class __$$UpdateMeasurementImplCopyWithImpl<$Res>
    extends _$MeasurementEventCopyWithImpl<$Res, _$UpdateMeasurementImpl>
    implements _$$UpdateMeasurementImplCopyWith<$Res> {
  __$$UpdateMeasurementImplCopyWithImpl(_$UpdateMeasurementImpl _value,
      $Res Function(_$UpdateMeasurementImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? m = null,
  }) {
    return _then(_$UpdateMeasurementImpl(
      null == m
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as Measurement,
    ));
  }
}

/// @nodoc

class _$UpdateMeasurementImpl implements _UpdateMeasurement {
  const _$UpdateMeasurementImpl(this.m);

  @override
  final Measurement m;

  @override
  String toString() {
    return 'MeasurementEvent.updateMeasurement(m: $m)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateMeasurementImpl &&
            (identical(other.m, m) || other.m == m));
  }

  @override
  int get hashCode => Object.hash(runtimeType, m);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateMeasurementImplCopyWith<_$UpdateMeasurementImpl> get copyWith =>
      __$$UpdateMeasurementImplCopyWithImpl<_$UpdateMeasurementImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getMeasurements,
    required TResult Function(Measurement m) createMeasurement,
    required TResult Function(Measurement m) updateMeasurement,
    required TResult Function(Measurement m) deleteMeasurement,
  }) {
    return updateMeasurement(m);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getMeasurements,
    TResult? Function(Measurement m)? createMeasurement,
    TResult? Function(Measurement m)? updateMeasurement,
    TResult? Function(Measurement m)? deleteMeasurement,
  }) {
    return updateMeasurement?.call(m);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getMeasurements,
    TResult Function(Measurement m)? createMeasurement,
    TResult Function(Measurement m)? updateMeasurement,
    TResult Function(Measurement m)? deleteMeasurement,
    required TResult orElse(),
  }) {
    if (updateMeasurement != null) {
      return updateMeasurement(m);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetMeasurements value) getMeasurements,
    required TResult Function(_CreateMeasurement value) createMeasurement,
    required TResult Function(_UpdateMeasurement value) updateMeasurement,
    required TResult Function(_DeleteMeasurement value) deleteMeasurement,
  }) {
    return updateMeasurement(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetMeasurements value)? getMeasurements,
    TResult? Function(_CreateMeasurement value)? createMeasurement,
    TResult? Function(_UpdateMeasurement value)? updateMeasurement,
    TResult? Function(_DeleteMeasurement value)? deleteMeasurement,
  }) {
    return updateMeasurement?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetMeasurements value)? getMeasurements,
    TResult Function(_CreateMeasurement value)? createMeasurement,
    TResult Function(_UpdateMeasurement value)? updateMeasurement,
    TResult Function(_DeleteMeasurement value)? deleteMeasurement,
    required TResult orElse(),
  }) {
    if (updateMeasurement != null) {
      return updateMeasurement(this);
    }
    return orElse();
  }
}

abstract class _UpdateMeasurement implements MeasurementEvent {
  const factory _UpdateMeasurement(final Measurement m) =
      _$UpdateMeasurementImpl;

  Measurement get m;
  @JsonKey(ignore: true)
  _$$UpdateMeasurementImplCopyWith<_$UpdateMeasurementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteMeasurementImplCopyWith<$Res> {
  factory _$$DeleteMeasurementImplCopyWith(_$DeleteMeasurementImpl value,
          $Res Function(_$DeleteMeasurementImpl) then) =
      __$$DeleteMeasurementImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Measurement m});
}

/// @nodoc
class __$$DeleteMeasurementImplCopyWithImpl<$Res>
    extends _$MeasurementEventCopyWithImpl<$Res, _$DeleteMeasurementImpl>
    implements _$$DeleteMeasurementImplCopyWith<$Res> {
  __$$DeleteMeasurementImplCopyWithImpl(_$DeleteMeasurementImpl _value,
      $Res Function(_$DeleteMeasurementImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? m = null,
  }) {
    return _then(_$DeleteMeasurementImpl(
      null == m
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as Measurement,
    ));
  }
}

/// @nodoc

class _$DeleteMeasurementImpl implements _DeleteMeasurement {
  const _$DeleteMeasurementImpl(this.m);

  @override
  final Measurement m;

  @override
  String toString() {
    return 'MeasurementEvent.deleteMeasurement(m: $m)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteMeasurementImpl &&
            (identical(other.m, m) || other.m == m));
  }

  @override
  int get hashCode => Object.hash(runtimeType, m);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteMeasurementImplCopyWith<_$DeleteMeasurementImpl> get copyWith =>
      __$$DeleteMeasurementImplCopyWithImpl<_$DeleteMeasurementImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getMeasurements,
    required TResult Function(Measurement m) createMeasurement,
    required TResult Function(Measurement m) updateMeasurement,
    required TResult Function(Measurement m) deleteMeasurement,
  }) {
    return deleteMeasurement(m);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getMeasurements,
    TResult? Function(Measurement m)? createMeasurement,
    TResult? Function(Measurement m)? updateMeasurement,
    TResult? Function(Measurement m)? deleteMeasurement,
  }) {
    return deleteMeasurement?.call(m);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getMeasurements,
    TResult Function(Measurement m)? createMeasurement,
    TResult Function(Measurement m)? updateMeasurement,
    TResult Function(Measurement m)? deleteMeasurement,
    required TResult orElse(),
  }) {
    if (deleteMeasurement != null) {
      return deleteMeasurement(m);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetMeasurements value) getMeasurements,
    required TResult Function(_CreateMeasurement value) createMeasurement,
    required TResult Function(_UpdateMeasurement value) updateMeasurement,
    required TResult Function(_DeleteMeasurement value) deleteMeasurement,
  }) {
    return deleteMeasurement(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetMeasurements value)? getMeasurements,
    TResult? Function(_CreateMeasurement value)? createMeasurement,
    TResult? Function(_UpdateMeasurement value)? updateMeasurement,
    TResult? Function(_DeleteMeasurement value)? deleteMeasurement,
  }) {
    return deleteMeasurement?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetMeasurements value)? getMeasurements,
    TResult Function(_CreateMeasurement value)? createMeasurement,
    TResult Function(_UpdateMeasurement value)? updateMeasurement,
    TResult Function(_DeleteMeasurement value)? deleteMeasurement,
    required TResult orElse(),
  }) {
    if (deleteMeasurement != null) {
      return deleteMeasurement(this);
    }
    return orElse();
  }
}

abstract class _DeleteMeasurement implements MeasurementEvent {
  const factory _DeleteMeasurement(final Measurement m) =
      _$DeleteMeasurementImpl;

  Measurement get m;
  @JsonKey(ignore: true)
  _$$DeleteMeasurementImplCopyWith<_$DeleteMeasurementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MeasurementState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() dirty,
    required TResult Function(List<Measurement> list) loaded,
    required TResult Function(MeasurementFailure f) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? dirty,
    TResult? Function(List<Measurement> list)? loaded,
    TResult? Function(MeasurementFailure f)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? dirty,
    TResult Function(List<Measurement> list)? loaded,
    TResult Function(MeasurementFailure f)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Dirty value) dirty,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Dirty value)? dirty,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Dirty value)? dirty,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MeasurementStateCopyWith<$Res> {
  factory $MeasurementStateCopyWith(
          MeasurementState value, $Res Function(MeasurementState) then) =
      _$MeasurementStateCopyWithImpl<$Res, MeasurementState>;
}

/// @nodoc
class _$MeasurementStateCopyWithImpl<$Res, $Val extends MeasurementState>
    implements $MeasurementStateCopyWith<$Res> {
  _$MeasurementStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$MeasurementStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'MeasurementState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() dirty,
    required TResult Function(List<Measurement> list) loaded,
    required TResult Function(MeasurementFailure f) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? dirty,
    TResult? Function(List<Measurement> list)? loaded,
    TResult? Function(MeasurementFailure f)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? dirty,
    TResult Function(List<Measurement> list)? loaded,
    TResult Function(MeasurementFailure f)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Dirty value) dirty,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Dirty value)? dirty,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Dirty value)? dirty,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements MeasurementState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$MeasurementStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'MeasurementState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() dirty,
    required TResult Function(List<Measurement> list) loaded,
    required TResult Function(MeasurementFailure f) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? dirty,
    TResult? Function(List<Measurement> list)? loaded,
    TResult? Function(MeasurementFailure f)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? dirty,
    TResult Function(List<Measurement> list)? loaded,
    TResult Function(MeasurementFailure f)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Dirty value) dirty,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Dirty value)? dirty,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Dirty value)? dirty,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements MeasurementState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$DirtyImplCopyWith<$Res> {
  factory _$$DirtyImplCopyWith(
          _$DirtyImpl value, $Res Function(_$DirtyImpl) then) =
      __$$DirtyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DirtyImplCopyWithImpl<$Res>
    extends _$MeasurementStateCopyWithImpl<$Res, _$DirtyImpl>
    implements _$$DirtyImplCopyWith<$Res> {
  __$$DirtyImplCopyWithImpl(
      _$DirtyImpl _value, $Res Function(_$DirtyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DirtyImpl implements _Dirty {
  const _$DirtyImpl();

  @override
  String toString() {
    return 'MeasurementState.dirty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DirtyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() dirty,
    required TResult Function(List<Measurement> list) loaded,
    required TResult Function(MeasurementFailure f) error,
  }) {
    return dirty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? dirty,
    TResult? Function(List<Measurement> list)? loaded,
    TResult? Function(MeasurementFailure f)? error,
  }) {
    return dirty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? dirty,
    TResult Function(List<Measurement> list)? loaded,
    TResult Function(MeasurementFailure f)? error,
    required TResult orElse(),
  }) {
    if (dirty != null) {
      return dirty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Dirty value) dirty,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return dirty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Dirty value)? dirty,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return dirty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Dirty value)? dirty,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (dirty != null) {
      return dirty(this);
    }
    return orElse();
  }
}

abstract class _Dirty implements MeasurementState {
  const factory _Dirty() = _$DirtyImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Measurement> list});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$MeasurementStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_$LoadedImpl(
      null == list
          ? _value._list
          : list // ignore: cast_nullable_to_non_nullable
              as List<Measurement>,
    ));
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl(final List<Measurement> list) : _list = list;

  final List<Measurement> _list;
  @override
  List<Measurement> get list {
    if (_list is EqualUnmodifiableListView) return _list;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_list);
  }

  @override
  String toString() {
    return 'MeasurementState.loaded(list: $list)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality().equals(other._list, _list));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_list));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() dirty,
    required TResult Function(List<Measurement> list) loaded,
    required TResult Function(MeasurementFailure f) error,
  }) {
    return loaded(list);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? dirty,
    TResult? Function(List<Measurement> list)? loaded,
    TResult? Function(MeasurementFailure f)? error,
  }) {
    return loaded?.call(list);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? dirty,
    TResult Function(List<Measurement> list)? loaded,
    TResult Function(MeasurementFailure f)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(list);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Dirty value) dirty,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Dirty value)? dirty,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Dirty value)? dirty,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements MeasurementState {
  const factory _Loaded(final List<Measurement> list) = _$LoadedImpl;

  List<Measurement> get list;
  @JsonKey(ignore: true)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({MeasurementFailure f});

  $MeasurementFailureCopyWith<$Res> get f;
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$MeasurementStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? f = null,
  }) {
    return _then(_$ErrorImpl(
      null == f
          ? _value.f
          : f // ignore: cast_nullable_to_non_nullable
              as MeasurementFailure,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $MeasurementFailureCopyWith<$Res> get f {
    return $MeasurementFailureCopyWith<$Res>(_value.f, (value) {
      return _then(_value.copyWith(f: value));
    });
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl(this.f);

  @override
  final MeasurementFailure f;

  @override
  String toString() {
    return 'MeasurementState.error(f: $f)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.f, f) || other.f == f));
  }

  @override
  int get hashCode => Object.hash(runtimeType, f);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() dirty,
    required TResult Function(List<Measurement> list) loaded,
    required TResult Function(MeasurementFailure f) error,
  }) {
    return error(f);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? dirty,
    TResult? Function(List<Measurement> list)? loaded,
    TResult? Function(MeasurementFailure f)? error,
  }) {
    return error?.call(f);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? dirty,
    TResult Function(List<Measurement> list)? loaded,
    TResult Function(MeasurementFailure f)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(f);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Dirty value) dirty,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Dirty value)? dirty,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Dirty value)? dirty,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements MeasurementState {
  const factory _Error(final MeasurementFailure f) = _$ErrorImpl;

  MeasurementFailure get f;
  @JsonKey(ignore: true)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
