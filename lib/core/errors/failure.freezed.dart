// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AuthFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() aOffline,
    required TResult Function() invalidEmailFailure,
    required TResult Function() invalidCodeFailure,
    required TResult Function() unautherizedFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? aOffline,
    TResult? Function()? invalidEmailFailure,
    TResult? Function()? invalidCodeFailure,
    TResult? Function()? unautherizedFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? aOffline,
    TResult Function()? invalidEmailFailure,
    TResult Function()? invalidCodeFailure,
    TResult Function()? unautherizedFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AOffline value) aOffline,
    required TResult Function(_InvalidEmailFailure value) invalidEmailFailure,
    required TResult Function(_InvalidCodeFailure value) invalidCodeFailure,
    required TResult Function(_UnautherizedFailure value) unautherizedFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AOffline value)? aOffline,
    TResult? Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult? Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult? Function(_UnautherizedFailure value)? unautherizedFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AOffline value)? aOffline,
    TResult Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult Function(_UnautherizedFailure value)? unautherizedFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res, AuthFailure>;
}

/// @nodoc
class _$AuthFailureCopyWithImpl<$Res, $Val extends AuthFailure>
    implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AOfflineImplCopyWith<$Res> {
  factory _$$AOfflineImplCopyWith(
          _$AOfflineImpl value, $Res Function(_$AOfflineImpl) then) =
      __$$AOfflineImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AOfflineImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$AOfflineImpl>
    implements _$$AOfflineImplCopyWith<$Res> {
  __$$AOfflineImplCopyWithImpl(
      _$AOfflineImpl _value, $Res Function(_$AOfflineImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AOfflineImpl implements _AOffline {
  const _$AOfflineImpl();

  @override
  String toString() {
    return 'AuthFailure.aOffline()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AOfflineImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() aOffline,
    required TResult Function() invalidEmailFailure,
    required TResult Function() invalidCodeFailure,
    required TResult Function() unautherizedFailure,
  }) {
    return aOffline();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? aOffline,
    TResult? Function()? invalidEmailFailure,
    TResult? Function()? invalidCodeFailure,
    TResult? Function()? unautherizedFailure,
  }) {
    return aOffline?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? aOffline,
    TResult Function()? invalidEmailFailure,
    TResult Function()? invalidCodeFailure,
    TResult Function()? unautherizedFailure,
    required TResult orElse(),
  }) {
    if (aOffline != null) {
      return aOffline();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AOffline value) aOffline,
    required TResult Function(_InvalidEmailFailure value) invalidEmailFailure,
    required TResult Function(_InvalidCodeFailure value) invalidCodeFailure,
    required TResult Function(_UnautherizedFailure value) unautherizedFailure,
  }) {
    return aOffline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AOffline value)? aOffline,
    TResult? Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult? Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult? Function(_UnautherizedFailure value)? unautherizedFailure,
  }) {
    return aOffline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AOffline value)? aOffline,
    TResult Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult Function(_UnautherizedFailure value)? unautherizedFailure,
    required TResult orElse(),
  }) {
    if (aOffline != null) {
      return aOffline(this);
    }
    return orElse();
  }
}

abstract class _AOffline implements AuthFailure {
  const factory _AOffline() = _$AOfflineImpl;
}

/// @nodoc
abstract class _$$InvalidEmailFailureImplCopyWith<$Res> {
  factory _$$InvalidEmailFailureImplCopyWith(_$InvalidEmailFailureImpl value,
          $Res Function(_$InvalidEmailFailureImpl) then) =
      __$$InvalidEmailFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidEmailFailureImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$InvalidEmailFailureImpl>
    implements _$$InvalidEmailFailureImplCopyWith<$Res> {
  __$$InvalidEmailFailureImplCopyWithImpl(_$InvalidEmailFailureImpl _value,
      $Res Function(_$InvalidEmailFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidEmailFailureImpl implements _InvalidEmailFailure {
  const _$InvalidEmailFailureImpl();

  @override
  String toString() {
    return 'AuthFailure.invalidEmailFailure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidEmailFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() aOffline,
    required TResult Function() invalidEmailFailure,
    required TResult Function() invalidCodeFailure,
    required TResult Function() unautherizedFailure,
  }) {
    return invalidEmailFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? aOffline,
    TResult? Function()? invalidEmailFailure,
    TResult? Function()? invalidCodeFailure,
    TResult? Function()? unautherizedFailure,
  }) {
    return invalidEmailFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? aOffline,
    TResult Function()? invalidEmailFailure,
    TResult Function()? invalidCodeFailure,
    TResult Function()? unautherizedFailure,
    required TResult orElse(),
  }) {
    if (invalidEmailFailure != null) {
      return invalidEmailFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AOffline value) aOffline,
    required TResult Function(_InvalidEmailFailure value) invalidEmailFailure,
    required TResult Function(_InvalidCodeFailure value) invalidCodeFailure,
    required TResult Function(_UnautherizedFailure value) unautherizedFailure,
  }) {
    return invalidEmailFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AOffline value)? aOffline,
    TResult? Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult? Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult? Function(_UnautherizedFailure value)? unautherizedFailure,
  }) {
    return invalidEmailFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AOffline value)? aOffline,
    TResult Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult Function(_UnautherizedFailure value)? unautherizedFailure,
    required TResult orElse(),
  }) {
    if (invalidEmailFailure != null) {
      return invalidEmailFailure(this);
    }
    return orElse();
  }
}

abstract class _InvalidEmailFailure implements AuthFailure {
  const factory _InvalidEmailFailure() = _$InvalidEmailFailureImpl;
}

/// @nodoc
abstract class _$$InvalidCodeFailureImplCopyWith<$Res> {
  factory _$$InvalidCodeFailureImplCopyWith(_$InvalidCodeFailureImpl value,
          $Res Function(_$InvalidCodeFailureImpl) then) =
      __$$InvalidCodeFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidCodeFailureImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$InvalidCodeFailureImpl>
    implements _$$InvalidCodeFailureImplCopyWith<$Res> {
  __$$InvalidCodeFailureImplCopyWithImpl(_$InvalidCodeFailureImpl _value,
      $Res Function(_$InvalidCodeFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidCodeFailureImpl implements _InvalidCodeFailure {
  const _$InvalidCodeFailureImpl();

  @override
  String toString() {
    return 'AuthFailure.invalidCodeFailure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InvalidCodeFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() aOffline,
    required TResult Function() invalidEmailFailure,
    required TResult Function() invalidCodeFailure,
    required TResult Function() unautherizedFailure,
  }) {
    return invalidCodeFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? aOffline,
    TResult? Function()? invalidEmailFailure,
    TResult? Function()? invalidCodeFailure,
    TResult? Function()? unautherizedFailure,
  }) {
    return invalidCodeFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? aOffline,
    TResult Function()? invalidEmailFailure,
    TResult Function()? invalidCodeFailure,
    TResult Function()? unautherizedFailure,
    required TResult orElse(),
  }) {
    if (invalidCodeFailure != null) {
      return invalidCodeFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AOffline value) aOffline,
    required TResult Function(_InvalidEmailFailure value) invalidEmailFailure,
    required TResult Function(_InvalidCodeFailure value) invalidCodeFailure,
    required TResult Function(_UnautherizedFailure value) unautherizedFailure,
  }) {
    return invalidCodeFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AOffline value)? aOffline,
    TResult? Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult? Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult? Function(_UnautherizedFailure value)? unautherizedFailure,
  }) {
    return invalidCodeFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AOffline value)? aOffline,
    TResult Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult Function(_UnautherizedFailure value)? unautherizedFailure,
    required TResult orElse(),
  }) {
    if (invalidCodeFailure != null) {
      return invalidCodeFailure(this);
    }
    return orElse();
  }
}

abstract class _InvalidCodeFailure implements AuthFailure {
  const factory _InvalidCodeFailure() = _$InvalidCodeFailureImpl;
}

/// @nodoc
abstract class _$$UnautherizedFailureImplCopyWith<$Res> {
  factory _$$UnautherizedFailureImplCopyWith(_$UnautherizedFailureImpl value,
          $Res Function(_$UnautherizedFailureImpl) then) =
      __$$UnautherizedFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnautherizedFailureImplCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res, _$UnautherizedFailureImpl>
    implements _$$UnautherizedFailureImplCopyWith<$Res> {
  __$$UnautherizedFailureImplCopyWithImpl(_$UnautherizedFailureImpl _value,
      $Res Function(_$UnautherizedFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnautherizedFailureImpl implements _UnautherizedFailure {
  const _$UnautherizedFailureImpl();

  @override
  String toString() {
    return 'AuthFailure.unautherizedFailure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnautherizedFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() aOffline,
    required TResult Function() invalidEmailFailure,
    required TResult Function() invalidCodeFailure,
    required TResult Function() unautherizedFailure,
  }) {
    return unautherizedFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? aOffline,
    TResult? Function()? invalidEmailFailure,
    TResult? Function()? invalidCodeFailure,
    TResult? Function()? unautherizedFailure,
  }) {
    return unautherizedFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? aOffline,
    TResult Function()? invalidEmailFailure,
    TResult Function()? invalidCodeFailure,
    TResult Function()? unautherizedFailure,
    required TResult orElse(),
  }) {
    if (unautherizedFailure != null) {
      return unautherizedFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AOffline value) aOffline,
    required TResult Function(_InvalidEmailFailure value) invalidEmailFailure,
    required TResult Function(_InvalidCodeFailure value) invalidCodeFailure,
    required TResult Function(_UnautherizedFailure value) unautherizedFailure,
  }) {
    return unautherizedFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AOffline value)? aOffline,
    TResult? Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult? Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult? Function(_UnautherizedFailure value)? unautherizedFailure,
  }) {
    return unautherizedFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AOffline value)? aOffline,
    TResult Function(_InvalidEmailFailure value)? invalidEmailFailure,
    TResult Function(_InvalidCodeFailure value)? invalidCodeFailure,
    TResult Function(_UnautherizedFailure value)? unautherizedFailure,
    required TResult orElse(),
  }) {
    if (unautherizedFailure != null) {
      return unautherizedFailure(this);
    }
    return orElse();
  }
}

abstract class _UnautherizedFailure implements AuthFailure {
  const factory _UnautherizedFailure() = _$UnautherizedFailureImpl;
}

/// @nodoc
mixin _$MembershipFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mmOffline,
    required TResult Function() cantGetPlan,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mmOffline,
    TResult? Function()? cantGetPlan,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mmOffline,
    TResult Function()? cantGetPlan,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MmOffline value) mmOffline,
    required TResult Function(_CantGetPlan value) cantGetPlan,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MmOffline value)? mmOffline,
    TResult? Function(_CantGetPlan value)? cantGetPlan,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MmOffline value)? mmOffline,
    TResult Function(_CantGetPlan value)? cantGetPlan,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MembershipFailureCopyWith<$Res> {
  factory $MembershipFailureCopyWith(
          MembershipFailure value, $Res Function(MembershipFailure) then) =
      _$MembershipFailureCopyWithImpl<$Res, MembershipFailure>;
}

/// @nodoc
class _$MembershipFailureCopyWithImpl<$Res, $Val extends MembershipFailure>
    implements $MembershipFailureCopyWith<$Res> {
  _$MembershipFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MmOfflineImplCopyWith<$Res> {
  factory _$$MmOfflineImplCopyWith(
          _$MmOfflineImpl value, $Res Function(_$MmOfflineImpl) then) =
      __$$MmOfflineImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MmOfflineImplCopyWithImpl<$Res>
    extends _$MembershipFailureCopyWithImpl<$Res, _$MmOfflineImpl>
    implements _$$MmOfflineImplCopyWith<$Res> {
  __$$MmOfflineImplCopyWithImpl(
      _$MmOfflineImpl _value, $Res Function(_$MmOfflineImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MmOfflineImpl implements _MmOffline {
  const _$MmOfflineImpl();

  @override
  String toString() {
    return 'MembershipFailure.mmOffline()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MmOfflineImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mmOffline,
    required TResult Function() cantGetPlan,
  }) {
    return mmOffline();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mmOffline,
    TResult? Function()? cantGetPlan,
  }) {
    return mmOffline?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mmOffline,
    TResult Function()? cantGetPlan,
    required TResult orElse(),
  }) {
    if (mmOffline != null) {
      return mmOffline();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MmOffline value) mmOffline,
    required TResult Function(_CantGetPlan value) cantGetPlan,
  }) {
    return mmOffline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MmOffline value)? mmOffline,
    TResult? Function(_CantGetPlan value)? cantGetPlan,
  }) {
    return mmOffline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MmOffline value)? mmOffline,
    TResult Function(_CantGetPlan value)? cantGetPlan,
    required TResult orElse(),
  }) {
    if (mmOffline != null) {
      return mmOffline(this);
    }
    return orElse();
  }
}

abstract class _MmOffline implements MembershipFailure {
  const factory _MmOffline() = _$MmOfflineImpl;
}

/// @nodoc
abstract class _$$CantGetPlanImplCopyWith<$Res> {
  factory _$$CantGetPlanImplCopyWith(
          _$CantGetPlanImpl value, $Res Function(_$CantGetPlanImpl) then) =
      __$$CantGetPlanImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CantGetPlanImplCopyWithImpl<$Res>
    extends _$MembershipFailureCopyWithImpl<$Res, _$CantGetPlanImpl>
    implements _$$CantGetPlanImplCopyWith<$Res> {
  __$$CantGetPlanImplCopyWithImpl(
      _$CantGetPlanImpl _value, $Res Function(_$CantGetPlanImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CantGetPlanImpl implements _CantGetPlan {
  const _$CantGetPlanImpl();

  @override
  String toString() {
    return 'MembershipFailure.cantGetPlan()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CantGetPlanImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mmOffline,
    required TResult Function() cantGetPlan,
  }) {
    return cantGetPlan();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mmOffline,
    TResult? Function()? cantGetPlan,
  }) {
    return cantGetPlan?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mmOffline,
    TResult Function()? cantGetPlan,
    required TResult orElse(),
  }) {
    if (cantGetPlan != null) {
      return cantGetPlan();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MmOffline value) mmOffline,
    required TResult Function(_CantGetPlan value) cantGetPlan,
  }) {
    return cantGetPlan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MmOffline value)? mmOffline,
    TResult? Function(_CantGetPlan value)? cantGetPlan,
  }) {
    return cantGetPlan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MmOffline value)? mmOffline,
    TResult Function(_CantGetPlan value)? cantGetPlan,
    required TResult orElse(),
  }) {
    if (cantGetPlan != null) {
      return cantGetPlan(this);
    }
    return orElse();
  }
}

abstract class _CantGetPlan implements MembershipFailure {
  const factory _CantGetPlan() = _$CantGetPlanImpl;
}

/// @nodoc
mixin _$MeasurementFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() msOffline,
    required TResult Function() noRecords,
    required TResult Function() msDbFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? msOffline,
    TResult? Function()? noRecords,
    TResult? Function()? msDbFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? msOffline,
    TResult Function()? noRecords,
    TResult Function()? msDbFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MsOffline value) msOffline,
    required TResult Function(_NoRecords value) noRecords,
    required TResult Function(_MsDbFailure value) msDbFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MsOffline value)? msOffline,
    TResult? Function(_NoRecords value)? noRecords,
    TResult? Function(_MsDbFailure value)? msDbFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MsOffline value)? msOffline,
    TResult Function(_NoRecords value)? noRecords,
    TResult Function(_MsDbFailure value)? msDbFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MeasurementFailureCopyWith<$Res> {
  factory $MeasurementFailureCopyWith(
          MeasurementFailure value, $Res Function(MeasurementFailure) then) =
      _$MeasurementFailureCopyWithImpl<$Res, MeasurementFailure>;
}

/// @nodoc
class _$MeasurementFailureCopyWithImpl<$Res, $Val extends MeasurementFailure>
    implements $MeasurementFailureCopyWith<$Res> {
  _$MeasurementFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MsOfflineImplCopyWith<$Res> {
  factory _$$MsOfflineImplCopyWith(
          _$MsOfflineImpl value, $Res Function(_$MsOfflineImpl) then) =
      __$$MsOfflineImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MsOfflineImplCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MsOfflineImpl>
    implements _$$MsOfflineImplCopyWith<$Res> {
  __$$MsOfflineImplCopyWithImpl(
      _$MsOfflineImpl _value, $Res Function(_$MsOfflineImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MsOfflineImpl implements _MsOffline {
  const _$MsOfflineImpl();

  @override
  String toString() {
    return 'MeasurementFailure.msOffline()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MsOfflineImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() msOffline,
    required TResult Function() noRecords,
    required TResult Function() msDbFailure,
  }) {
    return msOffline();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? msOffline,
    TResult? Function()? noRecords,
    TResult? Function()? msDbFailure,
  }) {
    return msOffline?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? msOffline,
    TResult Function()? noRecords,
    TResult Function()? msDbFailure,
    required TResult orElse(),
  }) {
    if (msOffline != null) {
      return msOffline();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MsOffline value) msOffline,
    required TResult Function(_NoRecords value) noRecords,
    required TResult Function(_MsDbFailure value) msDbFailure,
  }) {
    return msOffline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MsOffline value)? msOffline,
    TResult? Function(_NoRecords value)? noRecords,
    TResult? Function(_MsDbFailure value)? msDbFailure,
  }) {
    return msOffline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MsOffline value)? msOffline,
    TResult Function(_NoRecords value)? noRecords,
    TResult Function(_MsDbFailure value)? msDbFailure,
    required TResult orElse(),
  }) {
    if (msOffline != null) {
      return msOffline(this);
    }
    return orElse();
  }
}

abstract class _MsOffline implements MeasurementFailure {
  const factory _MsOffline() = _$MsOfflineImpl;
}

/// @nodoc
abstract class _$$NoRecordsImplCopyWith<$Res> {
  factory _$$NoRecordsImplCopyWith(
          _$NoRecordsImpl value, $Res Function(_$NoRecordsImpl) then) =
      __$$NoRecordsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoRecordsImplCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$NoRecordsImpl>
    implements _$$NoRecordsImplCopyWith<$Res> {
  __$$NoRecordsImplCopyWithImpl(
      _$NoRecordsImpl _value, $Res Function(_$NoRecordsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoRecordsImpl implements _NoRecords {
  const _$NoRecordsImpl();

  @override
  String toString() {
    return 'MeasurementFailure.noRecords()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoRecordsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() msOffline,
    required TResult Function() noRecords,
    required TResult Function() msDbFailure,
  }) {
    return noRecords();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? msOffline,
    TResult? Function()? noRecords,
    TResult? Function()? msDbFailure,
  }) {
    return noRecords?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? msOffline,
    TResult Function()? noRecords,
    TResult Function()? msDbFailure,
    required TResult orElse(),
  }) {
    if (noRecords != null) {
      return noRecords();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MsOffline value) msOffline,
    required TResult Function(_NoRecords value) noRecords,
    required TResult Function(_MsDbFailure value) msDbFailure,
  }) {
    return noRecords(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MsOffline value)? msOffline,
    TResult? Function(_NoRecords value)? noRecords,
    TResult? Function(_MsDbFailure value)? msDbFailure,
  }) {
    return noRecords?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MsOffline value)? msOffline,
    TResult Function(_NoRecords value)? noRecords,
    TResult Function(_MsDbFailure value)? msDbFailure,
    required TResult orElse(),
  }) {
    if (noRecords != null) {
      return noRecords(this);
    }
    return orElse();
  }
}

abstract class _NoRecords implements MeasurementFailure {
  const factory _NoRecords() = _$NoRecordsImpl;
}

/// @nodoc
abstract class _$$MsDbFailureImplCopyWith<$Res> {
  factory _$$MsDbFailureImplCopyWith(
          _$MsDbFailureImpl value, $Res Function(_$MsDbFailureImpl) then) =
      __$$MsDbFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MsDbFailureImplCopyWithImpl<$Res>
    extends _$MeasurementFailureCopyWithImpl<$Res, _$MsDbFailureImpl>
    implements _$$MsDbFailureImplCopyWith<$Res> {
  __$$MsDbFailureImplCopyWithImpl(
      _$MsDbFailureImpl _value, $Res Function(_$MsDbFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MsDbFailureImpl implements _MsDbFailure {
  const _$MsDbFailureImpl();

  @override
  String toString() {
    return 'MeasurementFailure.msDbFailure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MsDbFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() msOffline,
    required TResult Function() noRecords,
    required TResult Function() msDbFailure,
  }) {
    return msDbFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? msOffline,
    TResult? Function()? noRecords,
    TResult? Function()? msDbFailure,
  }) {
    return msDbFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? msOffline,
    TResult Function()? noRecords,
    TResult Function()? msDbFailure,
    required TResult orElse(),
  }) {
    if (msDbFailure != null) {
      return msDbFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MsOffline value) msOffline,
    required TResult Function(_NoRecords value) noRecords,
    required TResult Function(_MsDbFailure value) msDbFailure,
  }) {
    return msDbFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MsOffline value)? msOffline,
    TResult? Function(_NoRecords value)? noRecords,
    TResult? Function(_MsDbFailure value)? msDbFailure,
  }) {
    return msDbFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MsOffline value)? msOffline,
    TResult Function(_NoRecords value)? noRecords,
    TResult Function(_MsDbFailure value)? msDbFailure,
    required TResult orElse(),
  }) {
    if (msDbFailure != null) {
      return msDbFailure(this);
    }
    return orElse();
  }
}

abstract class _MsDbFailure implements MeasurementFailure {
  const factory _MsDbFailure() = _$MsDbFailureImpl;
}

/// @nodoc
mixin _$PerformanceFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noValues,
    required TResult Function() invalidValues,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noValues,
    TResult? Function()? invalidValues,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noValues,
    TResult Function()? invalidValues,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoValues value) noValues,
    required TResult Function(_InvalidValues value) invalidValues,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_NoValues value)? noValues,
    TResult? Function(_InvalidValues value)? invalidValues,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoValues value)? noValues,
    TResult Function(_InvalidValues value)? invalidValues,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PerformanceFailureCopyWith<$Res> {
  factory $PerformanceFailureCopyWith(
          PerformanceFailure value, $Res Function(PerformanceFailure) then) =
      _$PerformanceFailureCopyWithImpl<$Res, PerformanceFailure>;
}

/// @nodoc
class _$PerformanceFailureCopyWithImpl<$Res, $Val extends PerformanceFailure>
    implements $PerformanceFailureCopyWith<$Res> {
  _$PerformanceFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NoValuesImplCopyWith<$Res> {
  factory _$$NoValuesImplCopyWith(
          _$NoValuesImpl value, $Res Function(_$NoValuesImpl) then) =
      __$$NoValuesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoValuesImplCopyWithImpl<$Res>
    extends _$PerformanceFailureCopyWithImpl<$Res, _$NoValuesImpl>
    implements _$$NoValuesImplCopyWith<$Res> {
  __$$NoValuesImplCopyWithImpl(
      _$NoValuesImpl _value, $Res Function(_$NoValuesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoValuesImpl implements _NoValues {
  const _$NoValuesImpl();

  @override
  String toString() {
    return 'PerformanceFailure.noValues()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoValuesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noValues,
    required TResult Function() invalidValues,
  }) {
    return noValues();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noValues,
    TResult? Function()? invalidValues,
  }) {
    return noValues?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noValues,
    TResult Function()? invalidValues,
    required TResult orElse(),
  }) {
    if (noValues != null) {
      return noValues();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoValues value) noValues,
    required TResult Function(_InvalidValues value) invalidValues,
  }) {
    return noValues(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_NoValues value)? noValues,
    TResult? Function(_InvalidValues value)? invalidValues,
  }) {
    return noValues?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoValues value)? noValues,
    TResult Function(_InvalidValues value)? invalidValues,
    required TResult orElse(),
  }) {
    if (noValues != null) {
      return noValues(this);
    }
    return orElse();
  }
}

abstract class _NoValues implements PerformanceFailure {
  const factory _NoValues() = _$NoValuesImpl;
}

/// @nodoc
abstract class _$$InvalidValuesImplCopyWith<$Res> {
  factory _$$InvalidValuesImplCopyWith(
          _$InvalidValuesImpl value, $Res Function(_$InvalidValuesImpl) then) =
      __$$InvalidValuesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidValuesImplCopyWithImpl<$Res>
    extends _$PerformanceFailureCopyWithImpl<$Res, _$InvalidValuesImpl>
    implements _$$InvalidValuesImplCopyWith<$Res> {
  __$$InvalidValuesImplCopyWithImpl(
      _$InvalidValuesImpl _value, $Res Function(_$InvalidValuesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidValuesImpl implements _InvalidValues {
  const _$InvalidValuesImpl();

  @override
  String toString() {
    return 'PerformanceFailure.invalidValues()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InvalidValuesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noValues,
    required TResult Function() invalidValues,
  }) {
    return invalidValues();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noValues,
    TResult? Function()? invalidValues,
  }) {
    return invalidValues?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noValues,
    TResult Function()? invalidValues,
    required TResult orElse(),
  }) {
    if (invalidValues != null) {
      return invalidValues();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoValues value) noValues,
    required TResult Function(_InvalidValues value) invalidValues,
  }) {
    return invalidValues(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_NoValues value)? noValues,
    TResult? Function(_InvalidValues value)? invalidValues,
  }) {
    return invalidValues?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoValues value)? noValues,
    TResult Function(_InvalidValues value)? invalidValues,
    required TResult orElse(),
  }) {
    if (invalidValues != null) {
      return invalidValues(this);
    }
    return orElse();
  }
}

abstract class _InvalidValues implements PerformanceFailure {
  const factory _InvalidValues() = _$InvalidValuesImpl;
}
